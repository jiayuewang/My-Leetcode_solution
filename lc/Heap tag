http://www.ayqy.net/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88heapsort%EF%BC%89%E8%A7%A3%E6%9E%90/


一.堆排序的优缺点（pros and cons）
（还是简单的说说这个，毕竟没有必要浪费时间去理解一个糟糕的的算法）

优点：

堆排序的效率与快排、归并相同，都达到了基于比较的排序算法效率的峰值（时间复杂度为O(nlogn)）
除了高效之外，最大的亮点就是只需要O(1)的辅助空间了，既最高效率又最节省空间，只此一家了
堆排序效率相对稳定，不像快排在最坏情况下时间复杂度会变成O(n^2)），所以无论待排序序列是否有序，堆排序的效率都是O(nlogn)不变（注意这里的稳定特指平均时间复杂度=最坏时间复杂度，不是那个“稳定”，因为堆排序本身是不稳定的）
缺点：（从上面看，堆排序几乎是完美的，那么为什么最常用的内部排序算法是快排而不是堆排序呢？）

最大的也是唯一的缺点就是——堆的维护问题，实际场景中的数据是频繁发生变动的，而对于待排序序列的每次更新（增，删，改），我们都要重新做一遍堆的维护，以保证其特性，这在大多数情况下都是没有必要的。（所以快排成为了实际应用中的老大，而堆排序只能在算法书里面顶着光环，当然这么说有些过分了，当数据更新不很频繁的时候，当然堆排序更好些…）
二.内部原理
首先要知道堆排序的步骤：

构造初始堆，即根据待排序序列构造第一个大根堆或者小根堆（大根堆小根堆是什么？这个不解释了，稻草垛知道吧..）
首尾交换，断尾重构，即对断尾后剩余部分重新构造大（小）根堆
重复第二步，直到首尾重叠，排序完成
按小根堆排序结果是降序（或者说是非升序，不要在意这种细节..），按大根堆排序的结果是升序

上面这句话乍看好像不对（小根堆中最小元素在堆顶，数组组堆顶元素就是a[0]，怎么会是降序？），不过不用质疑这句话的正确性，看了下面这几幅图就明白了：

假设待排序序列是a[] = {7, 1, 6, 5, 3, 2, 4}，并且按大根堆方式完成排序

第一步（构造初始堆）：


{7, 5, 6, 1, 3, 2, 4}已经满足了大根堆，第一步完成

第二步（首尾交换，断尾重构）：


第三步（重复第二步，直至所有尾巴都断下来）：

无图，眼睛画瞎了，mspaint实在不好用。。到第二步应该差不多了吧，剩下的用笔也就画出来了。。

其实核心就是“断尾”，但可悲的是所有的资料上都没有明确说出来，可是，还有比“断尾”更贴切的描述吗？