

有一个字符串数组，从该字符串数组中找到两个字符串，要求满足这两个字符串之间没有相同的字母，同时它们的长度的乘积最大。

思路和代码
这道题的重点在于如何优化字符串的比较。直观的来说，我们无法避开复杂度为O(n^2)的循环因为必须进行两两比较才能识别出最大的乘积。但是我们可以优化字符串的比较。

既然只需要知道两个字符串是否有相同的字母，那么我们可以采用一种数据结构将每个单词所有的字母记录下来。这里采用的是二进制数的形式。
我们知道字母的数量不会超过26个，因此我们使用32位的整数来存储。将低26位的二进制数分别对应字母a-z，从而用二进制数实现一个简单的map。

因此单词ae对应的二进制数为00000000 00000000 00000000 00010001

那么比较两个单词是否有重复的字母只需要将二者的二进制形式进行&操作即可。如果没有重复字母，则结果应该为0.

我们首先要注意 int 在内存中以二进制形式存储，占据32位。我们用一个 int 型整数 ans 来记录结果，我们采用移位操作，
原因有两点：1. 注意到移位操作比乘2、除2操作效率更高，2. 移位操作很好地绕开了整型运算的溢出以及符号问题。在每次循环中：
ans 每次左移一位，当 n 的最低位为1时，ans 的最低位就变为1，n 每次右移一位。总共进行32次循环：

public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int reversed = 0;
        for (int i = 0; i < 32; i++) {
            reversed = (reversed << 1) | (n & 1);
            n = (n >> 1);
        }
        return reversed;
    }
}
